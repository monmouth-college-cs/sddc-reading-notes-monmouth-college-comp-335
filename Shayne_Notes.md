Author: Shayne Sendera
Description: A markdown file with the middle of chapter 2 summary(11-19).

### Mid-Chapter 2 Summary ###

Iterative models are an software engineering model that takes a problem and creates a solution one step at a time. A team will take the known requirements and prioritize them based on the most important features to the customer. Each iteration of this process is viewed as a small project that brings constant small updates to a system. This model is implemented through evolutionary prototyping which prioritizes requirements as they are received. Hence allows for products to contain many new features as time progresses. A downside to evolutionary prototyping is the overly optimistic views about time, money, and progress. This model becomes sort of inefficient as more requirements are added. Although the downsides may weigh upon this implementation, it tends to work well with small, close teams. Although plan-driven models have worked well in the past, the main issue with them is risk. Risk can be in the form of schedule slips, project cancellation, etc. Agile Methodologies on the other hand recognize this and minimizes the risk. In the mid 90's a new lightweight-plan-driven model was created. This differed from the heavyweight-plan-driven because it required less documentation and few process controls for small to medium sized projects. The projects generated by the lightweight model tend to be used as smaller projects that provide services toward a bigger project. In early 2001 the Agile Manifesto was written. This was a description of 4 values and 12 principles. The values will be lists at the bottom of the summary*. Another way to develop software is the eXtreme Programming(XP) method. It was created around 1995 and is described as a “lightweight, efficient, low-risk, flexible, predictable, scientific, and fun way to develop software.” The four fundamental ideas of this method is Heavy customer involvement, Continuous unit testing, Pair programming, and Short iteration cycles and frequent releases. The ideas around XP programming are what they say they are. There are a total of four main activities in XP: designing, coding, testing, and listening. Designing is creating structure that organizes the logic for the system. Coding is the main activity, and testing is very important for debugging. Listening involves gaining knowledge from your partner or the customer. XP is full of many standards, including its 12 practices(list below). The second agile methodology is Scrum, named after rugby, which means restarting the play after a rule is broken. Scrum is older than XP but the main difference is that scrum dev team typically consist of no more than 10 programmers. Similarly to other agile methods, Scrum puts an emphasis on small team efficacy and collective ownership.


### Agile Values ###
* Individuals and interactions over processes and tools
* Working software over comprehensive documentation
* Customer collaboration over contract negotiation
* Responding to change over following a plan

### Agile Principles ###

1. Our highest priority is to satisfy the customer through early and continuous delivery of valuable software.
2. Welcome changing requirements, even late in development. Agile processes harness change for the customer’s competitive advantage.
3. Deliver working software frequently, from a couple of weeks to a couple of months, with a preference to the shorter timescale.
4. Business people and developers must work together daily throughout the project.
5. Build projects around motivated individuals. Give them the environment and support they need, and trust them to get the job done.
6. The most efficient and effective method of conveying information to and within a development team is face-to-face conversation.
7. Working software is the primary way to measure progress.
8. Agile processes promote sustainable development. The sponsors, developers, and users should be able to maintain a constant pace indefinitely.
9. Continuous attention to technical excellence and good design enhances agility.
10. Simplicity—the art of maximizing the amount of work not done—is essential.
11. The best architectures, requirements, and designs emerge from self-organizing teams.
12. At regular intervals, the team reflects on how to become more effective and then tunes and adjusts its behavior accordingly.

### 12 XP Practices ###
* The planning game: Develop the scope of the next system release by combining buisness priority and technical issues
* Small releases
* Metaphor: A simple story of how the system works
* Simple Design
* Testing
* Refactoring: Restructure the system without changing its behavior.
* Pair programming
* Collective Ownership
* Continuous integration
* 40-hour week: Work a regular 40-hour week
* On-site customer: A customer that is apart of the team.
* Coding Standards
