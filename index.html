<!DOCTYPE html>
<html>
<head>
<title>Notes</title>
<style>
* {
    overflow-wrap: normal;
}
</style>

<script>
function setClassDisplay(type, checked) {
  var effect = (checked) ? "block":"none"; 
  var x = document.getElementsByClassName(type);
  for (var i = 0; i < x.length; i++) {
    x[i].style.display = effect;
  }
}

function CheckAnswer() {
  if (this.style.color == "black") {
    var bgColor = "orangered";
    if(this.classList.contains("right")) {
      bgColor = "lawngreen";
    }
    if(this.classList.contains("hidden")) {
      bgColor = "white";
    }
    this.style.backgroundColor = bgColor;
    this.style.color = "white";
  } else {
    this.style.backgroundColor = "white";
    this.style.color = "black";
  }
}

window.onload = function() {
  var answers = document.getElementsByClassName("answer");
  for(var i = 0; i < answers.length; i++) {
    answer = answers[i];
    var Color = "black";
    if(answer.classList.contains("hidden")) {
      Color = "white";
    }
    answer.style.color = Color;
    answer.onclick = CheckAnswer;
  }
}
</script>
</head>
<body>

<pre>
<a href="#1">1: Introduction to Software Development</a>
<a href="#2">2: Software Process Models</a>
  <a href="#2.5">2.5: Iterative Models</a>
  <a href="#2.6">2.6: Evolving the Iterative Model</a>
  <a href="#2.7">2.7: Risk: The Problem with Plan-Driven Models</a>
  <a href="#2.8">2.8: Agile Methodologies</a>
  <a href="#2.9">2.9: Agile Values and Principles</a>
  <a href="#2.10">2.10: eXtreme Programming (XP)</a>
  <a href="#2.11">2.11: XP Overview</a>
  <a href="#2.12">2.12: The Four Basic Activities</a>
  <a href="#2.13">2.13: Implementing XP: The 12 Practices</a>
  <a href="#2.14">2.14: Scrum</a>
  <a href="#2.15">2.15: Scrum Roles</a>
  <a href="#2.16">2.16: The Sprint</a>
  <a href="#2.17">2.17: Scrum Artifacts</a>
  <a href="#2.18">2.18: Sprint Flow</a>
  <a href="#2.19">2.19: Lean Software Development</a>
  <a href="#2.20">2.20: Kanban</a>
  <a href="#2.21">2.21: Kanban Board, WIP, and Flow</a>
  <a href="#2.22">2.22: Lead Time</a>
<a href="#3">3: Project Management Essentials</a>
  <a href="#3.1">3.1: Project Planning</a>
  <a href="#3.2">3.2: Project Organization</a>
  <a href="#3.3">3.3: Risk Analysis</a>
  <a href="#3.4">3.4: Resource Requirements</a>
  <a href="#3.5">3.5: Task Estimates</a>
  <a href="#3.6">3.6: Project Schedule</a>
  <a href="#3.7">3.7: Velocity</a>
  <a href="#3.8">3.8: Project Oversight</a>
  <a href="#3.9">3.9: Status Reviews and Presentations</a>
  <a href="#3.10">3.10: Defects</a>
  <a href="#3.11">3.11: The Retrospective</a>
  <a href="#3.12">3.12: Conclusion</a>

Display:
<input type="checkbox" onclick="setClassDisplay('summary',this.checked)" checked>Summaries
<input type="checkbox" onclick="setClassDisplay('questions',this.checked)" checked>Questions
<input type="checkbox" onclick="setClassDisplay('references',this.checked)" checked>References
</pre><br>

<h1 id="1">1: Introduction to Software Development</h1>

<span class="summary">
<h2>Summary</h2>
chapter 1 was a short chapter and it talk about the best way to develop software , you need to understand how to work with a team, so you need good communication skill. You also need understand how to work with customers and explain this to them. you need to use a process the everyone know so it would be easier to coordinate different code from different people in the same team. it also talks about understanding the right tools to use.<br>
</span>

<span class="questions">
<h2>Questions</h2>
How to keep track of everyone's work of a project in software developemnt?<br><br>

<b class="answer hidden">Assign small parts to a specific person and keep updated after each job is done.</b>
</span>

<span class="references">
<h2>References</h2>
"Software Project Management" (Ahmed, 2015)<br>
</span>

<h1 id="2">2: Software Process Models</h1>

<span class="summary">
<h2>Summary</h2>
<h3>Start of Chapter 2 Summary</h3>
this chapter talks about software process models and the four variables which are cost, time, quality, scope also called features. the chapter explain that you'll want to minimize each variables, and find the perfect spot for cost time quality and scope the make the best project. the book also explain that you need to focus on the features part of the project if your are the programmer because the cost and time your won't be able to control. late in the chapter the book talk about the waterfall process and that it's bad because it have you doing one thing then moving to the next its going linear, but that not how coding work people usually have to go back to some other part of the project to fix something or add something
<h3>Mid-Chapter 2 Summary</h3>
<p>Iterative models are an software engineering model that takes a problem and creates a solution one step at a time. A team will take 
the known requirements and prioritize them based on the most important features to the customer. Each iteration of this process is
viewed as a small project that brings constant small updates to a system. This model is implemented through evolutionary prototyping
which prioritizes requirements as they are received. Hence allows for products to contain many new features as time progresses. A
downside to evolutionary prototyping is the overly optimistic views about time, money, and progress. This model becomes sort of
inefficient as more requirements are added. Although the downsides may weigh upon this implementation, it tends to work well with
small, close teams. Although plan-driven models have worked well in the past, the main issue with them is risk. Risk can be in the
form of schedule slips, project cancellation, etc. Agile Methodologies on the other hand recognize this and minimizes the risk. In the
mid 90's a new lightweight-plan-driven model was created. This differed from the heavyweight-plan-driven because it required less
documentation and few process controls for small to medium sized projects. The projects generated by the lightweight model tend to be
used as smaller projects that provide services toward a bigger project. In early 2001 the Agile Manifesto was written. This was a
description of values and 12 principles. The values will be lists at the bottom of the summary*. Another way to develop software is
the eXtreme Programming(XP) method. It was created around 1995 and is described as a "lightweight, efficient, low-risk, flexible,
predictable, scientific, and fun way to develop software." The four fundamental ideas of this method is Heavy customer involvement,
Continuous unit testing, Pair programming, and Short iteration cycles and frequent releases. The ideas around XP programming are
what they say they are. There are a total of four main activities in XP: designing, coding, testing, and listening. Designing is
creating structure that organizes the logic for the system. Coding is the main activity, and testing is very important for debugging.
Listening involves gaining knowledge from your partner or the customer. XP is full of many standards, including its 12 practices(list
below). The second agile methodology is Scrum, named after rugby, which means restarting the play after a rule is broken. Scrum is
older than XP but the main difference is that scrum dev team typically consist of no more than 10 programmers. Similarly to other
agile methods, Scrum puts an emphasis on small team efficacy and collective ownership.</p>

<h3>Agile Values</h3><ul>
<li>Individuals and interactions over processes and tools</li>
<li>Working software over comprehensive documentation</li>
<li>Customer collaboration over contract negotiation</li>
<li>Responding to change over following a plan</li>
</ul>

<h3>Agile Principles</h3><ol>
<li>Our highest priority is to satisfy the customer through early and continuous delivery of valuable software.</li>
<li>Welcome changing requirements, even late in development. Agile processes harness change for the customer's competitive advantage.</li>
<li>Deliver working software frequently, from a couple of weeks to a couple of months, with a preference to the shorter timescale.</li>
<li>Business people and developers must work together daily throughout the project.</li>
<li>Build projects around motivated individuals. Give them the environment and support they need, and trust them to get the job done.</li>
<li>The most efficient and effective method of conveying information to and within a development team is face-to-face conversation.</li>
<li>Working software is the primary way to measure progress.</li>
<li>Agile processes promote sustainable development. The sponsors, developers, and users should be able to maintain a constant pace indefinitely.</li>
<li>Continuous attention to technical excellence and good design enhances agility.</li>
<li>Simplicity—the art of maximizing the amount of work not done—is essential.</li>
<li>The best architectures, requirements, and designs emerge from self-organizing teams.</li>
<li>At regular intervals, the team reflects on how to become more effective and then tunes and adjusts its behavior accordingly.</li>
</ol>

<h3>12 XP Practices</h3><ul>
<li>The planning game: Develop the scope of the next system release by combining buisness priority and technical issues</li>
<li>Small releases</li>
<li>Metaphor: A simple story of how the system works</li>
<li>Simple Design</li>
<li>Testing</li>
<li>Refactoring: Restructure the system without changing its behavior.</li>
<li>Pair programming</li>
<li>Collective Ownership</li>
<li>Continuous integration</li>
<li>40-hour week: Work a regular 40-hour week</li>
<li>On-site customer: A customer that is apart of the team.</li>
<li>Coding Standards</li>
</ul>
</span>

<h1 id="2.5">2.5: Iterative Models</h1>

<span class="questions">
<h2>Questions</h2>
Which of the following is not an advantage of iterative models?
<ol>
<li class="answer wrong">The customer is involved after the start of the development cycle.</li>
<li class="answer wrong">Mistakes by the programmers are accounted for.</li>
<li class="answer right">You know all the requirements for the final product at the start.</li>
</ol>
</span>

<span class="references">
<h2>References</h2>
Decription of Iterative Models: p. 11 para. 2-<br>
</span>

<h1 id="2.6">2.6: Evolving the Iterative Model</h1>
<span class="questions">
<h2>Questions</h2>
Which of the following isn't an upside of Evolutionary Prototyping?
<ol>
<li class="answer right">It makes scheduling easy and reliable.</li>
<li class="answer wrong">It works well with changing or ambiguous requirements.</li>
<li class="answer wrong">It makes it easier for the customer and management to track progress.</li>
</ol>

Which of the following isn't a downside of Evolutionary Prototyping?
<ol>
<li class="answer wrong">The code can be hard to maintain due to the frequently changing requirements.</li>
<li class="answer wrong">If too few requirements are implemented in each cycle, it can give an inaccurately high feeling of progress.</li>
<li class="answer right">The programmers are pushed into putting too much effort into making clean and bug-free code.</li>
</ol>

Evolutionary Prototyping is a recommended approach for new programmers.
<ol>
<li class="answer wrong">True</li>
<li class="answer right">False</li>
</ol>
</span>

<span class="references">
<h2>References</h2>
Definition of Evolutionary Prototyping: p. 12 para. 1<br>
</span>

<h1 id="2.7">2.7: Risk: The Problem with Plan-Driven Models</h1>
<span class="questions">
<h2>Questions</h2>
Which of the following is not an example of risk?
<ol>
<li class="answer right">Requirements Changing</li>
<li class="answer wrong">Schedule Slips</li>
<li class="answer wrong">False Feature Richness</li>
</ol>
</span>

<span class="references">
<h2>References</h2>
Examples of Risk: p. 13 para. 1<br>
</span>

<h1 id="2.8">2.8: Agile Methodologies</h1>

<span class="questions">
<h2>Questions</h2>
Who are Agile models meant for?
<ol>
<li class="answer right">Small teams making small projects</li>
<li class="answer wrong">Large teams making large projects</li>
<li class="answer wrong">Small teams making large projects</li>
</ol>

What does lightweight mean?<br><br>

<b class="answer hidden">Mainly involving coding, with little documentation</b>
</span>

<span class="references">
<h2>References</h2>
What lightweight means: p. 13 para. 4<br>
</span><h1 id="2.9">2.9: Agile Values and Principles</h1><span class="questions"><h2>Questions</h2>Which of the following isn't a value from the Agile Manifesto?
<ol>
<li class="answer wrong">Individuals and interactions over processes and tools</li>
<li class="answer right">Clean, clear code over coding quickly.</li>
<li class="answer wrong">Customer collaboration over contract negotiation</li>
</ol>

The writers of the Agile Manifesto thought that the latter items in each value were still valuable.
<ol>
<li class="answer right">True</li>
<li class="answer wrong">False</li>
</ol>
</span>

<span class="references">
<h2>References</h2>
Values of the Agile Manifesto: p. 14 list 1<br><br>

Principles of the Agile Manifesto: p. 14 list 2<br>
</span>

<h1 id="2.10">2.10: eXtreme Programming (XP)</h1>

<span class="questions">
<h2>Questions</h2>
What are the characteristics of eXtreme Programming?<br><br>

<b class="answer hidden">XP is a “lightweight, efficient, low-risk, flexible, predictable, scientific, and fun way to develop software.”</b>
</span>

<span class="references">
<h2>References</h2>
Beck, K. Extreme Programming Explained: Embrace Change. (Boston, MA: Addison-Wesley, 2000.)<br>
</span>

<h1 id="2.11">2.11: XP Overview</h1>

<span class="questions">
<h2>Questions</h2>
Which of the following isn't a fundamental idea of XP?
<ol>
<li class="answer wrong">Pair programming</li>
<li class="answer wrong">Continuous unit testing</li>
<li class="answer right">Work in progress</li>
</ol>
</span>

<span class="references">
<h2>References</h2>
Four Fundamental Ideas of XP: p. 15 list 1<br>
</span>

<h1 id="2.12">2.12: The Four Basic Activities</h1>
<span class="questions">
<h2>Questions</h2>
Which of the following activities isn't a part of XP?
<ol>
<li class="answer wrong">Designing</li>
<li class="answer right">Planning</li>
<li class="answer wrong">Listening</li>
</ol>
</span>

<span class="references"><h2>References</h2>Four Activities of XP: p. 16 list 1<br>
</span>

<h1 id="2.13">2.13: Implementing XP: The 12 Practices</h1>

<span class="questions">
<h2>Questions</h2>
Which of the following isn't a practice of XP?
<ol>
<li class="answer right">Iterating</li>
<li class="answer wrong">Metaphor</li>
<li class="answer wrong">Collective Ownership</li>
</ol>
</span>

<span class="references">
<h2>References</h2>
12 Practice of XP: p. 16 list 2 & p. 17 list 1 & p. 18 list 1<br>
</span>

<h1 id="2.14">2.14: Scrum</h1>

<span class="questions">
<h2>Questions</h2>
Scrum is:
<ol>
<li class="answer right">A management approach</li>
<li class="answer wrong">A programming approach</li>
<li class="answer wrong">A communication approach</li>
</ol>
</span>

<h1 id="2.15">2.15: Scrum Roles</h1>

<span class="questions">
<h2>Questions</h2>
User stories are:
<ol>
<li class="answer wrong">Feedback</li>
<li class="answer wrong">Input to a program</li>
<li class="answer right">Features</li>
</ol>

Which of the following isn't a role defined by Scrum?
<ol>
<li class="answer right">Project manager</li>
<li class="answer wrong">Product owner</li>
<li class="answer wrong">Scrum master</li>
<li class="answer wrong">Development team</li>
</ol>

The Scrum master makes the decisions.
<ol>
<li class="answer wrong">True</li>
<li class="answer right">False</li>
</ol>
</span>

<span class="references">
<h2>References</h2>
The Three Roles in Scrum: p. 19 para. 1-3<br>
</span>

<h1 id="2.16">2.16: The Sprint</h1>

<span class="summary">
<h2>Summary</h2>
A Sprint is an iteration of between one and four weeks. It's a fixed duration period and its output is determined by the amount of work done by the team in that period.<br>
</span>

<span class="questions">
<h2>Questions</h2>
Sprints are defined by their limited:
<ol>
<li class="answer wrong">Scope</li>
<li class="answer right">Time</li>
<li class="answer wrong">Budget</li>
</ol>
</span>

<span class="references">
<h2>References</h2>
The Sprint in Scrum: p. 19 para. 4<br>
</span>

<h1 id="2.17">2.17: Scrum Artifacts</h1>

<span class="summary">
<h2>Summary</h2>
Two backlogs in Scrum. <br>
1. Product Backlog: Created by the product owner. Is a list of all product requirements. Prioritised by the owner. <br>
2. Sprint Backlog: Created by the dev. team. Breakdown of the product backlog into a prioritized list. Usually a visual board(physical or digital). <br>
In an ongoing sprint, only the devs can add tasks to the sprint backlog. Outside entities can only add to the product backlog. <br>
</span>

<span class="questions">
<h2>Questions</h2>
Which of the following isn't a backlog in Scrum?
<ol>
<li class="answer wrong">The sprint backlog</li>
<li class="answer wrong">The product backlog</li>
<li class="answer right">The story backlog</li>
</ol>

Which of the following isn't allowed in Scrum?
<ol>
<li class="answer wrong">The product owner adding to the sprint backlog between sprints</li>
<li class="answer right">The product owner adding to the sprint backlog during a sprint</li>
<li class="answer wrong">The development team adding to the sprint backlog during a sprint</li>
</ol>

The sprint backlog is visual.
<ol>
<li class="answer right">True</li>
<li class="answer wrong">False</li>
</ol>
</span>

<span class="references">
<h2>References</h2>
The Scrum Backlogs: p. 9 para. 5<br><br>
</span>

<h1 id="2.18">2.18: Sprint Flow</h1>

<span class="summary">
<h2>Summary</h2>
Planning phase before sprint starts. User stories are divided into prioritized groups. Fill up the time allotted with tasks. No task in a sprint is longer than one day of work. Breaking the tasks down makes it easier to estimate them. <br>
Daily scrum meetings. No longer than 30 minutes. Help track progress. <br>
After everything is done, a final scrum brings closure to the whole process. Requirements left in the product backlog is added to the next release. <br>
</span>

<h1 id="2.19">2.19: Lean Software Development</h1>

<span class="summary">
<h2>Summary</h2>
Set of principles designed to improve productivity, quality and customer satisfaction. <br><br>

Seven key principles of Poppendiecks:<br>
1. Eliminate waste: Eliminate everything that doesn't add value to the product. <br>
2. Build quality in: Two techniques used to improve quality; Pair programming and Test driven development (TDD). Constant feedback is another technique. <br>
3. Create knowledge: The team must learn new things constantly. <br>
4. Defer commitment: To make the big, irreversible decisions for later. <br>
5. Deliver fast: Make it reasonably as fast as possible. Stick to the lean principles to optimize that. <br>
6. Respect people: Pretty clear<br>
7. Optimize the whole: Keep the bigger picture in mind. <br>
</span>

<h1 id="2.20">2.20: Kanban</h1>

<span class="summary">
<h2>Summary</h2>
Derived from lean manufacturing. Three main ideas: work-in-progress, flow and lead time. <br>
</span>

<h1 id="2.21">2.21: Kanban Board, WIP, and Flow</h1>

<span class="summary">
<h2>Summary</h2>
WIP and flow depicted visually on a Kanban board. Similar to a scrum task board. <br>
</span>

<h1 id="2.22">2.22: Lead Time</h1>

<span class="summary">
<h2>Summary</h2>
It's the amount of time it takes for the team to move a task from one column to another in the kanban board. The date the task is started in the ToDo column is called entry date. The day it's done in called the done date. <br>
</span>

<h1 id="3">3: Project Management Essentials</h1>

<span class="summary">
<h2>Summary</h2>
Understanding project management is required. Tasks involved:
<ul>
<li>Project planning</li>
<li>Estimation and scheduling</li>
<li>Resource management</li>
<li>Project oversight</li>
<li>Project reviews and presentations</li>
<li>The project retrospective</li>
</ul>
Project managers are responsible for
<ul>
<li>managing scope, costs, estimation, schedule, quality, personnel, communication, risk, etc.</li>
</ul>
The team manage the Agile project. They need to make to sure there is no delay in management decision-making. If there is a manager,
<ul>
<li>make sure the team has the resources</li>
<li>ensure the team adheres to agile values and principles</li>
<li>facilitate communication</li>
<li>shield the team from outside interruptions</li>
</ul>
</span>

<span class="questions">
<h2>Questions</h2>
As developers, what tasks do we need to focus on the most? (Pg: 29)

<b class="answer hidden">
<ul>
<li>Project planning</li>
<li>Estimation and scheduling</li>
<li>Resource management</li>
<li>Project oversight</li>
<li>Project reviews and presentations</li>
<li>The project retrospective</li>
</ul>
</b>

(T/F) In agile projects, the teammates are only responsible for managing their portion of the project. (Pg: 29)<br><br>

<b class="answer hidden">
False (Agile projects allow everyone on the team to be responsible for the whole project)</b>
</span>

<h1 id="3.1">3.1: Project Planning</h1>

<span class="summary">
<h2>Summary</h2>
For a plan-driven process model, a project plan is an actual document of how the project will be managed, written by the project manager.<br><br>

A project plan has seven parts:
<ul>
<li>Introdution and explanation of the project</li>
<li>Team organization</li>
<li>Risk analysis</li>
<li>Hardware, software, and human resource requirements</li>
<li>Task list and size and effort estimates</li>
<li>Project schedule</li>
<li>Project monitoring and reporting mechanisms</li>
</ul>
An agile project is feature-based, mulitlayer and organized into iterations. The project is owned by the team.<br>
</span>

<span class="questions">
<h2>Questions</h2>
(T/F) Project planning is done and fixed from the beginning. (Pg: 30)<br><br>

<b class="answer hidden">False (Project planning is a fluid and continuous process)</b><br><br>

What is a project plan? List different parts of it. (Pg: 30)<br><br>

<b class="answer hidden">It's a document written by the project manager and then approved by both the dev. team and upper management.<br><br>

Consists of following parts:
<ul>
<li>Introduction and explanation of the project</li>
<li>Team organization</li>
<li>Risk analysis</li>
<li>Hardware, software, and human resource requirements</li>
<li>Task list and size and effort estimates</li>
<li>Project schedule</li>
<li>Project monitoring and reporting mechanisms, collectively known as project oversight</li>
</ol>
</b>
</span>

<h1 id="3.2">3.2: Project Organization</h1>

<span class="summary">
<h2>Summary</h2>
Three things for project organization are:
<ul>
<li>How you are going to organize the team</li>
<li>Deciding the process model</li>
<li>Managing the project on day-to-day basis</li>
</ul>
These are important for brand new projects and inexperienced teams because it will help you to start the actual project work.<br><br>

Since Agile team is small, it is easy to organize the project. The code, testings and expertise are all shared within the team. Being in an agile team will improve a lot of skills learning new things doing agile projects.<br><br>

Agile projects are iterative, use short development cycles, and produce running code with more features at the end of each iteration. The team has daily meetings, integrations and shared or paired programming.<br>
</span>

<span class="questions">
<h2>Questions</h2>
How are agile projects organized on a daily basis? (Pg: 31)<br><br>

<b class="answer hidden">On a daily basis, developers do daily meetings/integrations. The work iterations are usually very small and most of the time is spent writing executing tests.</b>
</span>

<h1 id="3.3">3.3: Risk Analysis</h1>

<span class="summary">
<h2>Summary</h2>
We need to think of possible factors that can go wrong and how we are going to prevent from happening.
<ul>
<li>Schedule slips : A task could take longer than we expected. When it happens, we need to report immediately the estimated late time. It could happen often when there is not regular status meetings like plan-driven project.</li>
<li>Defect rate is excessive : If the program has a lot of bugs in tests, we should pause writing codes and look at the code a little bit and clean up the bug.</li>
<li>Requirements misunderstood : Regular meetings and frequent releases will help the misunderstanding between customers and developers.</li>
<li>Requirement churn : To release an update, it requires adding new features and fixing bugs. Churn happens when the customer continues to change requirements while development is underway.</li>
<li>Turnover : Best way to reduce turnover is to 1) give developers interesting work 2) have them work in pleasant enviroment 3) give them control over their own schedules.</li>
</ul>
All the risks are needed to address and find a way to avoid the risk. We can remove some feature from a release, stop work on new features and do a bug hunt, negotiate new features into a future release, which is called mitigation. Then, we should have a plan to handle identifiable risks.<br>
</span>

<span class="questions">
<h2>Questions</h2>
What are the general risks to look out for?<br><br>

<b class="answer hidden">
<ul>
<li>Schedule slips</li>
<li>Excessive defect rate</li>
<li>Misunderstanding the requirements</li>
<li>Changing the requirements regularly</li>
<li>Turnover</li>
</ul>
</b>
</span>

<span class="references">
<h2>References</h2>
How are new requirements dealt with? (Pg: 32)<br><br>

The new requirements are reviewed/examined by a change control board(CCB). They decide whether to add a new requirement to the list of things to be implemented.<br><br>

What some good ways to deal with turnover? (Pg: 32)<br><br>

If a developer leaves, the overload of work should be equally divided amongst everyone on the team. Principles like <i>common code ownership</i> and <i>paired programming</i> help divide that work efficiently.<br>
</span>

<h1 id="3.4">3.4: Resource Requirements</h1>

<span class="summary">
<h2>Summary</h2>
(pg 33)<br><br>

Resource Requirements are a simple part of management where you identify the whats, whens and wheres of the resources of the project. It includes Workstations, people, software, hardware and more.<br>
</span>

<h1 id="3.5">3.5: Task Estimates</h1>

<span class="summary">
<h2>Summary</h2>
(pg 33)<br><br>

The first steps towards a schedule is seeing what you'll be doing and figuring out how long each step will take. Task estimates are just that, estimates. It is impossible to know exactly how long a specific task will take and how accurate the developers prediction is largely based off of experience. The bigger the task the harder it is to know so it is better to breat down tasks that are estimated to take about a week or shorter. Then you can add them together and start doing larger estimates. "The estimation mantra is: size first, then effort and cost estimates, finally schedule."(pg 33) "Managers should never do development estimates. Even if a manager has been a developer in the past, unless they're deeply involved in the actual development work, they shouldn't be in the business of doing development estimates."(pg 34)<br>
</span>

<span class="questions">
<h2>Questions</h2>
What is NOT a variable in the estimation mantra? (pg.33)
<ul>
<li class="answer wrong">Effort and Costs</li>
<li class="answer wrong">Program Size</li>
<li class="answer right">Program Quality</li>
<li class="answer wrong">Schedule</li>
</ul>

What is the Delphi estimation technique? (short answer) (pg.33)<br><br>

<b class="answer hidden">
Give a developer work to do, after they have some time to consider the solution ask them for 3 numbers. These 3 numbers represent:
<ol>
<li>The minimum amount of time it will take to complete</li>
<li>The maximum amount of time it will take to complete</li>
<li>The normal amount of time it will take to complete</li>
</ol>
</b>
</span>

<span class="references">
<h2>References</h2>
Delphi estimation technique: pg. 33 (last 2 paragraphs)
<ol>
<li>The minimum amount of time it will take to complete</li>
<li>The maximum amount of time it will take to complete</li>
<li>The normal amount of time it will take to complete</li>
</ol>
</span>

<h1 id="3.6">3.6: Project Schedule</h1>

<span class="summary">
<h2>Summary</h2>
(pg 34-35)<br><br>

Once you have the task estimates you can create a schedule. Important things to think about when making a cycle include the dependencies between tasks, your duty cycle, inclusion of sickdays and vacations, as well as the inability to schedule a developer to work on two tasks at once. It is also usedful to use project-scheduling software to make the schedule. It allows for greater organisation, especially for larger projects. Spolsky's Painless Schedule (pg 35) lists the following that should be in every schedule:
<ul>
<li>Feature name</li>
<li>Tasks within the feature</li>
<li>The Priority of the task</li>
<li>The Original Estimate (in person hours)</li>
<li>The Current Estimate (in person-hours)</li>
<li>The Elapsed Time worked on the task (in person-hours)</li>
<li>The Remaining Time on the task (also in person-hours)</li>
</ul>
</span>

<span class="questions">
<h2>Questions</h2>
What is a duty cycle? (Short Answer) (pg.35)<br><br>

<b class="answer hidden">Answer should say something along the lines of:<br><br>
"The amount of person hours (per day) a developer actually spends developing software"</b><br><br>

How many items are in Spolsky's Painless schedule? (pg.35)
<ul>
<li class="answer wrong">7</li>
<li class="answer wrong">5</li>
<li class="answer wrong">11</li>
<li class="answer right">9</li>
</ul>
</span>

<span class="references">
<h2>References</h2>
Project Schedule (pg. 34)<br><br>

Once you have time estimates for an iteration, you can create a schedule. 4 items (below) state what you should consider while creating the schedule.
<ul>
<li>Have developers state the dependencies between tasks. Some can't start until other dependencies finish.</li>
<li>Find out what the duty cycle is.</li>
<li>Consider weekends, vacations, sick days, training, etc.</li>
<li>One developer can only one task at a time.</li>
</ul>


Spolsky's Painless Schedule (pg. 35)

<ul>
<li>Feature name</li>
<li>Future tasks</li>
<li>The priority of the task</li>
<li>The original estimate in person hours</li>
<li>The current estimate in person hours</li>
<li>The elapsed time in person hours</li>
<li>The remaining time in person hours</li>
</ul>
</span>

<h1 id="3.7">3.7: Velocity</h1>

<span class="summary">
<h2>Summary</h2>
(pg 35)<br><br>

The Velocity of a task can also prove useful when creating a schedule. The velocity is defined as the estimated effort of a task, divided by the actual effort. If you overestimate your task, your velocity will be greater than one (your task took less time than you originally thought); if you underestimate, it will be less than one (the task took you longer than you originally thought). Ideally, velocity should be 1.0, but that hardly ever happens. Velocity can be used to give both the manager and the developers an idea of how accurate their predictions are.<br>
</span>

<span class="questions">
<h2>Questions</h2>
What is the ideal velocity of a project? (pg.35)
<ul>
<li class="answer wrong">0</li>
<li class="answer wrong">2.0</li>
<li class="answer right">1.0</li>
<li class="answer wrong">0.5</li>
</ul>

True or false, the ideal velocity is commonly achieved? # (pg.36)
<ul>
<li class="answer right">False</li>
<li class="answer wrong">True</li>
</ul>
</span>

<span class="references">
<h2>References</h2>
Velocity (pgs. 35-36)
<ul>
<li>Allows managers and developers to have an idea of how accurate their estimates were. This allows for schedule improvement. PG.35-36</li>
</ul>
</span>

<h1 id="3.8">3.8: Project Oversight</h1>

<span class="summary">
<h2>Summary</h2>
Project oversight is the part of project management that happens during the programming portion of a project. It includes meetings to discuss the current architure, design and code of the project, as well as management of the schedule, developers, process, and the manager themselves. How it is handled is part of the agreed upon project process.<br><br>
The manager also has to keep the developers happy and motivated, mainly by avoiding things like motivating through fear, treating the developers as resources, or allowing the developers to get caught up in distractions outside the realm of writing the program.<br>
</span>

<h1 id="3.9">3.9: Status Reviews and Presentations</h1>

<span class="summary">
<h2>Summary</h2>
Status reviews are a part of every project, though larger projects have more formal ones. It is important to be honest and direct about your current progress and expected progress before the next review, as well as any problems you've run into. Avoid the temptation to just say what management wants to hear, because that leads to problems later.<br><br>
When giving a presentation, design it around the knowledge level of the audience and the purpose of the presentation. When using PowerPoint, keep the presentations short and to the point, and keep the slides barebones and the bullet points brief and not full sentences.<br>
</span>

<h1 id="3.10">3.10: Defects</h1>

<span class="summary">
<h2>Summary</h2>
Developers should try to minimize the amount of defects they introduce into their code. Despite this, defects will inevitably find their way into code, so developers should also try to find as many of the defects in code as possible before releasing it. The found defects can be referenced in a defect tracking system, which tracks current known defects and their severity. For example, one possible set of levels of severity is:
<ol>
<li>Fatal: Crashes or non-functioning vital features</li>
<li>Severe: Non-functioning major features</li>
<li>Serious: Non-functioning major features with work-arounds</li>
<li>Annoying: Defect or error that may annoy the user, but doesn't affect functionality</li>
<li>New Feature Request: A request for a new feature (not a defect)</li>
</ol>
When fixing defects, developers should start with the highest severity ones. Developers should never release a product with Fatal or Severe defects in it, and in most cases should also remove Serious defects.<br>
</span>

<span class="questions">
<h2>Questions</h2>
if you don't know what the defect is how would you make a defect tracking system if you don't know what your tracking?<br><br>

<b class="answer hidden">you have to wait till the program is being used and a defect happen in order to track similar defects.</b>
</span>

<span class="references">
<h2>References</h2>
Defect levels(pg 37)
<ol>
<li>fatal: the program crashes</li>
<li>severe: A major piece of the project don't work</li>
<li>serious: A little piece of the project don't work but you can get around it</li>
<li>Annoying: minor defect or error but not a big problem.</li>
<li>new features: you have to add something new to your project.</li>
</ol>
the first 3 levels should be caught before the program is released  
</span>

<h1 id="3.11">3.11: The Retrospective</h1>

<span class="summary">
<h2>Summary</h2>
Retrospectives are done after completing some goal, whether a project or major iteration under a plan-driven process, or an iteration, such as a sprint, under an agile process. During retrospectives, questions are asked about the developers' experience completing the goal, such as:
<ol>
<li>What went right? Did things go as expected, and did we implement all the features the customer wanted?</li>
<li>What went wrong? How many defects did we need to deal with, and how much overtime did we need to finish on time?</li>
<li>What process issues came up? Which aspects of our planned process were problematic or infeasable in practice?</li>
<li>What do we need to fix for next time? Given our answers to the previous questions, what do we need to fix in our process, work habits, or environment for the next project?</li>
<li>Who's responsible for the fixes? Who should be in charge of making sure we follow our modified process?</li>
</ol>
</span>

<span class="questions">
<h2>Questions</h2>
1.  what is the importance of the Retrospective part of the project?<br><br>

<b class="answer hidden">the importance of the Retrospective part of the project is that you get to see what you did wrong and what you didn't right also get to take a look at how you team did overall. you get to take a bird's-eyes view</b>
</span>

<span class="references">
<h2>References</h2>
The Retrospective(pg 38)
<ol>
<li>what went right/wrong? did it go as plan</li>
<li>how many defects did it take longer then expected.</li>
<li>did you follow the process, if not why</li>
<li>what can you/the team improve on for next project.</li>
<li>who should fix the problems if there was any.</li>
</ol>
</span>

<h1 id="3.12">3.12: Conclusion</h1>

<span class="summary">
<h2>Summary</h2>
The developers should own the process and management should be supportive, listen to the developers (especially when it comes to schedules and estimates), and seperate the developers from distractions outside their roles.<br>
</span>

</body>
</html>
