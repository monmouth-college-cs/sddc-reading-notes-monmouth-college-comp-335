# Chapter 3 Questions (First part, Pg: 29-32)

## Questions

### Introduction

#### As developers, what tasks do we need to focus on the most? (Pg: 29)

-   Project planning
-   Estimation and scheduling
-   Resource management
-   Project oversight
-   Project reviews and presentations
-   The project retrospective

#### (T/F) In agile projects, the teammates are only responsible for managing their portion of the porject. (Pg: 29)

False (Agile projects allow everyone on the team to be responsible for the whole project)

### Project Planning

#### (T/F) Project planning is done and fixed from the beginning. (Pg: 30)

False (Project planning is a fluid and continuous process)

#### What is a project plan? List different parts of it. (Pg: 30)

It's a document written by the project manager and then approved by both the dev. team and upper management.

Consists of following parts:
-   Introduction and explanation of the project
-   Team organization
-   Risk analysis
-   Hardware, software, and human resource requirements
-   Task list and size and effort estimates
-   Project schedule
-   Project monitoring and reporting mechanisms, collectively known as project
oversight

### Project Organization

#### How are agile projects organized on a daily basis? (Pg: 31)

On a daily basis, developers do daily meetings/integrations. The work iterations are usually very small and most of the time is spent writing executing tests. 

### Risk Analysis

#### What are the general risks to look out for?

-   Schedule slips
-   Excessive defect rate
-   Misunderstanding the requirements
-   Changing the requirements regularly
-   Turnover


## References

#### How are new requirements dealt with? (Pg: 32)

The new requirements are reviewed/examined by a change control board(CCB). They decide whether to add a new requirement to the list of things to be implemented.

#### What some good ways to deal with turnover? (Pg: 32)

If a developer leaves, the overload of work should be equally divided amongst everyone on the team. Principles like *common code ownership* and *paired programming* help divide that work efficiently. 